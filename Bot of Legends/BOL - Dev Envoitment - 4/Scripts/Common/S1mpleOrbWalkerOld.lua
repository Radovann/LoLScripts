_G.S1OrbLoading = true


-- http://bol-tools.com/ tracker
assert(load(Base64Decode("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"), nil, "bt", _ENV))()
TrackerLoad("xwcsl4vNguBEn5UW")

assert(load(Base64Decode("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"), nil, "bt", _ENV))() ScriptStatus("XKNOMRRNKMJ") 

--[[
API & Function Documentation 1.6

Globals sorted by date of creation
	_G.S1mpleOrbLoaded = returns true if S1OW is completly loaded (boolean)
	_G.S1OrbLoading = returns true if S1OW is loading (boolean)

Functions sorted by date of creation
	Please don't call any own my functions that is not listed here

	:GetBuildings() = returns all enemy Buildings (table)
	:update() = Ask's my Server for an Update (You should NEVER execute this function)
	:AddToMenu(Menu) = has to be called externaly, otherwise my Script will shutdown
	:AddCallback(_function,_type) = Add a function as Callback, valid types:
		"before", "while", "after" (string)
	:RemoveCallback(_function, _type) = Remove a function as Callback, valid types:
		"before", "while", "after" (string)
		returns true if function got removed (boolean)
	:setOrbMode(arg) = Set the OrbWalker Mode to the Specific Mode
		Not very usefull cause it get's overriden next Tick
	:canAA() = returns if unit can AA (boolean)
	:canMove() = returns if unit can Move (boolean)
	:GetLatency = returns the current Ping (number)
	:ResetAA() = resets the AA Timer
	:ResetAAandAA(target) = resets the AA Timer and auto attacks the Target. (if no target -> target = aatarget)
	:ForceAA(target) = Attacks the target. (if no target -> target = aatarget)

Members sorted by date of creation
	Non Listed Members are not very usefull for external scripts,
	but feel free to find and use them

	.version = returns version (number)
	.hasupdated = returns if S1OW has updated (boolean)
	.menu = returns the S1OW Menu (custom)
	.mractive = returns if Movement Reinveted is active (boolean)
	.myTeam = returns the own Team (number)
	.aarange = returns the base AA Range of the Champion (number)
	.aaprojectilespeed = returns the Heroes AA Projectile Speed (number)
	.Buildings = returns table of all Enemy Buildings (table)
	.lastAttackTime = returns last time the unit has attacked (number)
	.lastWindUpTime = returns the duration of this Units WindUp (number)
	.lastAttackCD = returns the last AA Cooldown (number)
	.aamode = returns the current AA Mode (string)
	.lastmove = returns the last Time the Unit has moved (number)
	.minionMan = returns a Minion Manager (custom)
	.jungleMan = returns a JungleMinion Manager (custom)
	.aatarget = returns the current AA target (object)
	.beforeAACallbacks = returns a Table of Functions, that will be executed before the AA happens (table)
		Get's called OnAnimation
	.whileAACallbacks = returns a Table of Functions, that will be executed while the AA happens (table)
		Get's called OnAnimation+windUpTime+animationTime
	.afterAACallbacks = returns a Table of Functions, that will be executed after the AA happens (table)
		Get's called as soon as canAA returns true again
	.enemyheroes = Returns enemy Heroes (table)
	.allowedtoAA = Set to false to disable AutoAttacks from this OrbWalker (boolean)
	.allowedtoMove = Set to false to disable AutoMovement from this OrbWalker (boolean)
	.AntiAAcancle = Get's changed dynamicly to prevent AA Cancles (number)

]]

class("S1mpleOrbWalker")
function S1mpleOrbWalker:__init()
	if _G.S1mpleOrbLoaded then return end
		self:printC("Welcome "..GetUser())

		if FHPrediction or _G.FHPrediction then
			self.prediction = "FHPred"
		elseif FileExist(LIB_PATH .. "VPrediction.lua") then
			self.prediction = "VPred"
			require("VPrediction")
			VPred = VPrediction()
		else
			self.prediction = "none"
		end
		
		--External Stuff
			--General
				self.version = 1.8
				self.hasupdated = false
				self.menu = nil
				self.mractive = false
			--OrbWalker
				--static
					self.myTeam = myHero.team
					self.aarange = myHero.range + myHero.boundingRadius
					self.projectilespeeds = {
						["Velkoz"] = 2000 ,
						["Xerath"] = 2000.0000 ,
						["Thresh"] = 1000.0000 ,
						["Ziggs"] = 1500.0000 ,
						["KogMaw"] = 1800.0000 ,
						["Skarner"] = 500.0000 ,
						["Katarina"] = 467.0000 ,
						["Riven"] = 347.79999 ,
						["Ashe"] = 2000.0000 ,
						["Soraka"] = 1000.0000 ,
						["Jinx"] = 2750.0000 ,
						["JarvanIV"] = 20.0000 ,
						["Tryndamere"] = 347.79999 ,
						["Singed"] = 700.0000 ,
						["Diana"] = 347.79999 ,
						["Yasuo"] = 347.79999 ,
						["Ahri"] = 1750.0000 ,
						["Lulu"] = 1450.0000 ,
						["Lissandra"] = 2000.0000 ,
						["Draven"] = 1700.0000 ,
						["FiddleSticks"] = 1750.0000 ,
						["Sivir"] = 1750.0000 ,
						["Corki"] = 2000.0000 ,
						["Janna"] = 1200.0000 ,
						["Jax"] = 400.0000 ,
						["Shen"] = 400.0000 ,
						["Sona"] = 1500.0000 ,
						["Caitlyn"] = 2500.0000 ,
						["Trundle"] = 347.79999 ,
						["Malphite"] = 1000.0000 ,
						["Vi"] = 1000.0000 ,
						["Anivia"] = 1400.0000 ,
						["Heimerdinger"] = 1500.0000 ,
						["Evelynn"] = 467.0000 ,
						["Rumble"] = 347.79999 ,
						["Leblanc"] = 1700.0000 ,
						["Viktor"] = 2300.0000 ,
						["XinZhao"] = 20.0000 ,
						["Orianna"] = 1450.0000 ,
						["Vladimir"] = 1400.0000 ,
						["Nidalee"] = 1750.0000 ,
						["Syndra"] = 1800.0000 ,
						["Zac"] = 1000.0000 ,
						["Olaf"] = 347.79999 ,
						["Veigar"] = 1100.0000 ,
						["Twitch"] = 2500.0000 ,
						["Akali"] = 467.0000 ,
						["Urgot"] = 1300.0000 ,
						["Leona"] = 347.79999 ,
						["Karma"] = 1500.0000 ,
						["Jayce"] = 347.79999 ,
						["Galio"] = 1000.0000 ,
						["TwistedFate"] = 1500.0000 ,
						["Varus"] = 2000.0000 ,
						["Garen"] = 347.79999 ,
						["Swain"] = 1600.0000 ,
						["Vayne"] = 2000.0000 ,
						["Fiora"] = 467.0000 ,
						["Quinn"] = 2000.0000 ,
						["Brand"] = 2000.0000 ,
						["Teemo"] = 1300.0000 ,
						["Amumu"] = 500.0000 ,
						["Annie"] = 1200.0000 ,
						["Elise"] = 1600.0000 ,
						["Nami"] = 1500.0000 ,
						["Poppy"] = 500.0000 ,
						["Tristana"] = 2250.0000 ,
						["Graves"] = 3000.0000 ,
						["Morgana"] = 1600.0000 ,
						["MissFortune"] = 2000.0000 ,
						["Cassiopeia"] = 1200.0000 ,
						["Volibear"] = 467.0000 ,
						["Irelia"] = 467.0000 ,
						["Lucian"] = 2800.0000 ,
						["Udyr"] = 467.0000 ,
						["MonkeyKing"] = 20.0000 ,
						["Kennen"] = 1600.0000 ,
						["Nunu"] = 500.0000 ,
						["Ryze"] = 2400.0000 ,
						["Zed"] = 467.0000 ,
						["Nautilus"] = 1000.0000 ,
						["Gangplank"] = 1000.0000 ,
						["Lux"] = 1600.0000 ,
						["Sejuani"] = 500.0000 ,
						["Ezreal"] = 2000.0000 ,
						["Khazix"] = 500.0000 ,
						["Aatrox"] = 347.79999 ,
						["Hecarim"] = 500.0000 ,
						["Pantheon"] = 20.0000 ,
						["Shyvana"] = 467.0000 ,
						["Zyra"] = 1700.0000 ,
						["Karthus"] = 1200.0000 ,
						["Zilean"] = 1200.0000 ,
						["Chogath"] = 500.0000 ,
						["Malzahar"] = 2000.0000
					}
					self.aaprojectilespeed = myHero.range > 300 and (self.projectilespeeds[myHero.charName] and self.projectilespeeds[myHero.charName] or math.huge) or math.huge
					self.enemyheroes = GetEnemyHeroes()
				--non Static
					self.Buildings = {}
					self.lastAttackTime = 0
					self.lastWindUpTime = 0
					self.lastAttackCD = 0
					self.aamode = "none"
					self.lastmove = 0
					self.minionMan = minionManager(MINION_ENEMY, self.aarange, player, MINION_SORT_HEALTH_ASC)
					self.jungleMan = minionManager(MINION_JUNGLE, self.aarange, player, MINION_SORT_HEALTH_ASC)
					self.minionMan.range = self.aarange
					self.jungleMan.range = self.aarange
					self.aatarget = nil
					self.nextmovePos = nil
					self.allowedtoAA = true --This only get's set externaly
					self.allowedtoMove = true  --This only get's set externaly
					self.lastMRModeChange = 0
					self.lastAttack = 0
					self.lasttickcanAA = true
					self.AntiAAcancle = 0
				--Callbacks
					self.beforeAACallbacks = {} --Please don't write in here
					self.whileAACallbacks = {} --Please don't write in here
					self.afterAACallbacks = {} --Please don't write in here

		self:update()
		self.Buildings = self:GetBuildings()
		--Register BoL Callbacks
			AddUnloadCallback(function ()
				self:log("Unloading S1mpleOrbWalker")
				self:log("=========================\n")
			end)
			AddTickCallback(function ()
				self:setMRMode()
				self:setOrbMode()
				self:MoveOrFight()
				self:HandleAfterAttackCallback()
			end)
			AddDrawCallback(function ()
				self:draw()
			end)
			AddAnimationCallback(function(unit,animation)
				self:OnAnimation(unit,animation)
			end)
			AddApplyBuffCallback(function (source,unit,buff)
				self:OnApplyBuff(source,unit,buff)
			end)
			AddRemoveBuffCallback(function (source,unit,buff)
				self:OnRemoveBuff(source,unit,buff)
			end)

		_G.S1mpleOrbLoaded = true



end

function S1mpleOrbWalker:GetBuildings()
	local Towers = {}
	for i = 1, objManager.maxObjects, 1 do
        local object = objManager:getObject(i)
        if object and (object.type == "obj_AI_Turret" or object.type == "obj_HQ" or object.type == "obj_BarracksDampener") and object.team ~= player.team and object.health > 0 then
        	Towers[#Towers+1] = object
        end
    end
    return Towers
end

function S1mpleOrbWalker:AddCallback(_function,_type)
	if not _function or type(_function) ~= "function" or not _type or type(_type) ~= "string" then self:errorC("AddCallback", "Incorrect Argument") return end
	if _type:lower() == "before" then
		self.beforeAACallbacks[#self.beforeAACallbacks+1] = _function
	elseif _type:lower() == "while" then
		self.whileAACallbacks[#self.whileAACallbacks+1] = _function
	elseif _type:lower() == "after" then
		self.afterAACallbacks[#self.afterAACallbacks+1] = _function
	end
end

function S1mpleOrbWalker:RemoveCallback(_function, _type)
	if not _function or type(_function) ~= "function" or not _type or type(_type) ~= "string" then self:errorC("RemoveCallback", "Incorrect Argument") return end
	if _type:lower() == "before" then
		for i,v in pairs(self.beforeAACallbacks) do
			if v == _function then
				table.remove(self.beforeAACallbacks, i)
				return true
			end
		end
		return false
	elseif _type:lower() == "while" then
		for i,v in pairs(self.beforeAACallbacks) do
			if v == _function then
				table.remove(self.beforeAACallbacks, i)
				return true
			end
		end
		return false
	elseif _type:lower() == "after" then
		for i,v in pairs(self.beforeAACallbacks) do
			if v == _function then
				table.remove(self.beforeAACallbacks, i)
				return true
			end
		end
		return false
	end
end

function S1mpleOrbWalker:draw()
	if not self.menu then return end
	if self.menu.orb.adv.debug then
		DrawTextA("AAMode: "..self.aamode,20,20,20)
		DrawTextA("CanAA: "..tostring(self:canAA()),20,20,40)
		DrawTextA("CanMove: "..tostring(self:canMove()),20,20,60)
	end
	if self.menu.orb.mr.enabled and not self.menu.orb.adv.debug then
		DrawTextA("Movement Reinvented enabled",12,20,20)
		DrawTextA("Auto Attack Mode: "..self.aamode,12,20,32, ARGB(255,0,255,0))
	end
	if self.menu.orb.draw.aarange then
		DrawCircle3D(myHero.x,myHero.y,myHero.z, self.aarange,1,ARGB(255,0,255,0))
	end
	if self.menu.orb.draw.killable or self.menu.orb.draw.soon then
		self.minionMan:update()
		self.jungleMan:update()

		local t = {}
		for _, v in pairs(self.minionMan.objects) do
			if ValidTarget(v) and GetDistance(v) < self.aarange*1.5 then
				t[#t+1] = v
			end
		end
		for _, v in pairs(self.jungleMan.objects) do
			if ValidTarget(v) and GetDistance(v) < self.aarange*1.5 then
				t[#t+1] = v
			end
		end
		for _,v in pairs(t) do
			local hpp = v.health/v.maxHealth*100
			local dmg = self:RealADDamage(v, myHero, {name = "Basic"}, 0)
			if dmg > v.health and self.menu.orb.draw.killable then
				DrawCircle3D(v.x,v.y,v.z,30, 3, ARGB(255,255-25.5*hpp,255,25.5*hpp))
			elseif dmg*3 > v.health and self.menu.orb.draw.soon then
				DrawCircle3D(v.x,v.y,v.z,30, 1, ARGB(150,255-25.5*hpp,255,25.5*hpp))
			end
		end
	end

end

function S1mpleOrbWalker:setOrbMode(arg) --Set the OrbMode if not mr
	if arg and type(arg) == "string" then self.aamode = arg return end
	if not self.menu then return end
	if not self.menu.orb.mr.enabled then --mr modes writes on Key Press
		if self.menu.orb.keys.HarassKey then
			self.aamode = "harass"
		elseif self.menu.orb.keys.LaneClearKey then
			self.aamode = "laneclear"
		elseif self.menu.orb.keys.LastHitKey then
			self.aamode = "lasthit"
		elseif self.menu.orb.keys.SBTWKey then
			self.aamode = "sbtw"
		else
			self.aamode = "none"
		end
	end
end

function S1mpleOrbWalker:MoveOrFight() --Decide wheter to move or fight
	if self.aamode == "none" then
		self.aatarget = nil
		return
	end
	if self.allowedtoAA then
		self:GetRange()
		self:GetTarget()
	end
	if self.allowedtoMove then
		self.nextmovePos = self:GetNextMovementPos()
	end
	if self.aatarget then
		if self:canAA() and self.allowedtoAA then
			self:fight()
		elseif self.allowedtoMove  and self:canMove() then
			self:move()
		end
		return
	else
		if self.allowedtoMove and self:canMove() then
			self:move()
		end
	end
end

function S1mpleOrbWalker:GetChampionTarget() --returns lowlife Champion in range
	local target = nil
	for _,v in pairs(self.enemyheroes) do
		if ValidTarget(v) and GetDistance(v) < self.aarange then
			if not target then
				target = v
			elseif target.health > v.health then
				target = v
			end
		end
	end
	return target
end

function S1mpleOrbWalker:GetLowlifeMinion() --returns lowlife Minion in range
	self.minionMan:update()
	self.jungleMan:update()

	local t = {}
	for _, v in pairs(self.minionMan.objects) do
		if ValidTarget(v) and GetDistance(v) < self.aarange then
			t[#t+1] = v
		end
	end
	for _, v in pairs(self.jungleMan.objects) do
		if ValidTarget(v) and GetDistance(v) < self.aarange then
			t[#t+1] = v
		end
	end

	local target = nil
	for _,v in pairs(t) do
		if not target then
			target = v
		elseif target.health > v.health then
			target = v
		end
	end
	return target
end

function S1mpleOrbWalker:GetLasthitableMinion() --Returns only a lasthitable Minion
	self.minionMan.range = self.aarange
	self.jungleMan.range = self.aarange
	self.minionMan:update()
	self.jungleMan:update()

	local t = {}
	for _, v in pairs(self.minionMan.objects) do
		if ValidTarget(v) and GetDistance(v) < self.aarange then
			t[#t+1] = v
		end
	end
	for _, v in pairs(self.jungleMan.objects) do
		if ValidTarget(v) and GetDistance(v) < self.aarange then
			t[#t+1] = v
		end
	end

	local target = nil
	for _,v in pairs(t) do
		if self:RealADDamage(v, myHero, {name = "Basic"}, 0) > self:PredictHealth(v,GetDistance(v)/self.aaprojectilespeed) then
			if not target then
				target = v
			elseif target.health > v.health then
				target = v
			end
		end
	end
	return target
end

function S1mpleOrbWalker:GetBuildingInRange()
	for _,v in pairs(self.Buildings) do
		if ValidTarget(v) and GetDistance(v) < self.aarange+v.boundingRadius then
			return v
		end
	end
end

function S1mpleOrbWalker:GetTarget() --Get Valid AA Target
	local target = nil
	self.aatarget = nil
	if self.aamode == "sbtw" then
		target = self:GetChampionTarget()
	elseif self.aamode == "harass" then
		target = self:GetLasthitableMinion()
		if not target then
			target = self:GetChampionTarget()
		end
	elseif self.aamode == "lasthit" then
		target = self:GetLasthitableMinion()
	elseif self.aamode == "laneclear" then
		target = self:GetLowlifeMinion()
		target = self:willimissLastHits(target)
		if not target then
			target = self:GetBuildingInRange()
		end
	end
	self.aatarget = target
end

function S1mpleOrbWalker:willimissLastHits(target)
	if not target then return nil end

	local dmg = self:RealADDamage(target, myHero, {name = "Basic"}, 0)
	if dmg > target.health then
		return target
	end

	if self.prediction == "none" then return target end

	local time = self.lastAttack + self.lastAttackCD
	if self:PredictHealth(target,time) < dmg then
			return nil
		else
			return target
		end
	return target
end

function S1mpleOrbWalker:PredictHealth(target,time)
	if not target then return math.huge end
	if self.prediction == "FHPred" and self.menu.orb.adv.usepred then
		return FHPrediction.PredictHealth(target, time)*self.menu.orb.adv.FHpredbuffer
	elseif self.prediction == "VPred" and self.menu.orb.adv.usepred then
		return VPred:GetPredictedHealth(target, time)*self.menu.orb.adv.VPpredbuffer
	else
		return target.health
	end
end

function S1mpleOrbWalker:GetNextMovementPos() --Get next Movement Position and validate it
	if not self.menu then return end
	local pos = nil
	if self.menu.orb.mr.enabled then
		posMR = self:getMovementReinventedPosition()
		pos = D3DXVECTOR3(posMR.x,posMR.y,posMR.z)
	else
		pos = mousePos
	end
	if pos and IsWall(pos) and self.menu.orb.adv.blockwall then
		return myHero.pos
	elseif pos then
		return pos
	else
		self:errorC("GetNextMovementPos", "No Position found",false)
		return mousePos
	end
end

function S1mpleOrbWalker:fight() --Auto Attack the Target
	if self.aatarget and self.aatarget.valid then --Just for security
		myHero:Attack(self.aatarget)
	end
end

function S1mpleOrbWalker:move() --Move to target Position
	if not self.menu then return end
	if self.nextmovePos then --Just for security
		if GetDistance(self.nextmovePos, myHero.pos) > 20 then
			if self.lastmove+self.menu.orb.human.moveorderdelay < os.clock() then
				myHero:MoveTo(self.nextmovePos.x,self.nextmovePos.z)
				self.lastmove = os.clock()
			end
		end
	end
end

function S1mpleOrbWalker:setMRMode() --Sets the Movement Reinvented Mode on Keypress
	local function table_invert(t)
		local u = {}
		for k, v in pairs(t) do u[v] = k end
		return u
	end

	if not self.menu then return end
	if self.menu.orb.mr.enabled then
		if self.lastMRModeChange+0.2 < os.clock() then
			if self.menu.orb.mr.key.orbkey then
				self.lastMRModeChange = os.clock()
				local aamodes = {"sbtw","harass","lasthit","laneclear","flee","none"}
				local invt = table_invert(aamodes)
				local _next = aamodes[invt[self.aamode]+1]
				if _next ~= nil then
					self.aamode = _next
				else
					self.aamode = "sbtw"
				end
			end
		end
	end
end

function S1mpleOrbWalker:getMovementReinventedPosition(m)
	local up = self.menu.orb.mr.key.up
	local down = self.menu.orb.mr.key.down
	local left = self.menu.orb.mr.key.left
	local right = self.menu.orb.mr.key.right
	local upleft = self.menu.orb.mr.key.upleft
	local upright = self.menu.orb.mr.key.upright
	local downleft = self.menu.orb.mr.key.downleft
	local downright = self.menu.orb.mr.key.downright

	movelenght = m or 250
	movedir = ""
	if up then
		if left then
			movedir = "ul"
		elseif right then
			movedir = "ur"
		elseif upright then
			movedir = "uur"
		elseif upleft then
			movedir = "uul"
		else
			movedir = "u"
		end
	end

	if down then
		if left then
			movedir = "dl"
		elseif right then
			movedir = "dr"
		elseif downright then
			movedir = "ddr"
		elseif downleft then
			movedir = "ddl"
		else
			movedir = "d"
		end
	end

	if not up and not down then
		if left then
			if upleft then
				movedir = "llu"
			elseif downleft then
				movedir = "lld"
			else
				movedir = "l"
			end
		elseif right then
			if upright then
				movedir = "rru"
			elseif downright then
				movedir = "rrd"
			else
				movedir = "r"
			end
		end
	end
	if movedir == "" then
		if upleft then
			movedir = "llu"
		elseif downleft then
			movedir = "lld"
		elseif upright then
			movedir = "rru"
		elseif downright then
			movedir = "rrd"
		end
	end

	local pos = nil
	if movedir == "u" then
		pos = self:DoMove(myHero.x, myHero.z+movelenght,movelenght)
	elseif movedir == "d" then
		pos = self:DoMove(myHero.x, myHero.z-movelenght,movelenght)
	elseif movedir == "l" then
		pos = self:DoMove(myHero.x-movelenght, myHero.z,movelenght)
	elseif movedir == "r" then
		pos = self:DoMove(myHero.x+movelenght, myHero.z,movelenght)
	elseif movedir == "ul" then
		pos = self:DoMove(myHero.x-movelenght, myHero.z+movelenght,movelenght)
	elseif movedir == "ur" then
		pos = self:DoMove(myHero.x+movelenght, myHero.z+movelenght,movelenght)
	elseif movedir == "dl" then
		pos = self:DoMove(myHero.x-movelenght, myHero.z-movelenght,movelenght)
	elseif movedir == "dr" then
		pos = self:DoMove(myHero.x+movelenght, myHero.z-movelenght,movelenght)
	elseif movedir == "uur" then
		pos = self:DoMove(myHero.x+movelenght/2, myHero.z+movelenght,movelenght)
	elseif movedir == "uul" then
		pos = self:DoMove(myHero.x-movelenght/2, myHero.z+movelenght,movelenght)
	elseif movedir == "ddr" then
		pos = self:DoMove(myHero.x+movelenght/2, myHero.z-movelenght,movelenght)
	elseif movedir == "ddl" then
		pos = self:DoMove(myHero.x-movelenght/2, myHero.z-movelenght,movelenght)
	elseif movedir == "llu" then
		pos = self:DoMove(myHero.x-movelenght, myHero.z+movelenght/2,movelenght)
	elseif movedir == "lld" then
		pos = self:DoMove(myHero.x-movelenght, myHero.z-movelenght/2,movelenght)
	elseif movedir == "rru" then
		pos = self:DoMove(myHero.x+movelenght, myHero.z+movelenght/2,movelenght)
	elseif movedir == "rrd" then
		pos = self:DoMove(myHero.x+movelenght, myHero.z-movelenght/2,movelenght)
	end
	if not pos then pos = myHero.pos end
	return pos
end

function S1mpleOrbWalker:DoMove(x,y,m)
	local d3vec = D3DXVECTOR3(x, myHero.y, y)
	if IsWall(d3vec) and m > 125 then
		self:getMovementReinventedPosition(m/2)
	else
		return d3vec
	end
end

function S1mpleOrbWalker:GetLatency() --In millisec
	return GetLatency() / 2000
end

function S1mpleOrbWalker:OnAnimation(unit,animation)
	if unit and unit.isMe and animation and animation:find("Attack") then
		local t = self.aatarget
		if t then
			beforehealth = t.health
		end
		for _,v in pairs(self.beforeAACallbacks) do
			v()
		end
		local spellProc = unit.spell
		self.windUpTime = spellProc.windUpTime

		self.lastAttack = GetTickCount() - GetLatency() * 0.5
		self.lastWindUpTime = unit.spell.windUpTime * 1000
		self.lastAttackCD = unit.spell.animationTime * 1000
		DelayAction(function ()
			for _,v in pairs(self.whileAACallbacks) do
				v()
			end
		end,unit.spell.windUpTime)
		DelayAction(function ()
			if beforehealth and self.menu.orb.adv.aacancleprev then
				if not t or t.dead then 
					self.AntiAAcancle =  self.AntiAAcancle - 0.25
				elseif beforehealth == t.health then
					if self.AntiAAcancle < 0 then
						self.AntiAAcancle = self.AntiAAcancle + 1
					else
						self.AntiAAcancle = self.AntiAAcancle + 0.5
					end
				elseif beforehealth > t.health and self.AntiAAcancle > -20 then
					self.AntiAAcancle =  self.AntiAAcancle - 0.25
				end
			end
		end,self.windUpTime+unit.spell.animationTime)
	end
end

function S1mpleOrbWalker:canMove() --Thanks to Bilbao for this Function
	return (GetTickCount() + GetLatency() * 0.5 > self.lastAttack + self.lastWindUpTime +20 + self.AntiAAcancle) and (self.lastmove+self.menu.orb.human.moveorderdelay < os.clock())
end

function S1mpleOrbWalker:canAA()
	return (GetTickCount() + GetLatency() * 0.5 > self.lastAttack + self.lastAttackCD)
end

function S1mpleOrbWalker:HandleAfterAttackCallback()
	if not self:canAA() then
		self.lasttickcanAA = false
	elseif self.lasttickcanAA == false then
		self.lasttickcanAA = true
		for _,v in pairs(self.afterAACallbacks) do
			v()
		end
	end
end

function S1mpleOrbWalker:ResetAA()
	self.lastAttack = 0
end

function S1mpleOrbWalker:ResetAAandAA(target)
	self.lastAttack = 0
	if not target then target = self.aatarget end
	if not target then return end
	myHero:Attack(target)
end

function S1mpleOrbWalker:ForceAA(target)
	if not target then target = self.aatarget end
	if not target then return end
	myHero:Attack(target)
end

function S1mpleOrbWalker:GetRange()
	if not myHero then return end
	self.aarange = myHero.range + myHero.boundingRadius
end

function S1mpleOrbWalker:OnApplyBuff(source, unit,buff)
	if unit and unit.isMe then
		self:GetRange()
	end
end

function S1mpleOrbWalker:OnRemoveBuff(source, unit,buff)
	if unit and unit.isMe then
		self:GetRange()
	end
end

function S1mpleOrbWalker:GetAAMode()
	return self.aamode
end

function S1mpleOrbWalker:tostring()
	return "S1mpleOrbWalker"
end
















function S1mpleOrbWalker:RealADDamage(target, source, spell, additionalDamage)
	--Big Thanks to VPrediction
	-- read initial armor and damage values
    local armorPenPercent = source.armorPenPercent
    local armorPen = source.armorPen
    local totalDamage = source.totalDamage + (additionalDamage or 0)
    local damageMultiplier = spell.name:find("CritAttack") and 2 or 1

    -- minions give wrong values for armorPen and armorPenPercent
    if source.type == "obj_AI_Minion" then
        armorPenPercent = 1
    elseif source.type == "obj_AI_Turret" then
        armorPenPercent = 0.7
    end

    -- turrets ignore armor penetration and critical attacks
    if target.type == "obj_AI_Turret" then
        armorPenPercent = 1
        armorPen = 0
        damageMultiplier = 1
    end

    -- calculate initial damage multiplier for negative and positive armor

    local targetArmor = (target.armor * armorPenPercent) - armorPen
    if targetArmor < 0 then -- minions can't go below 0 armor.
        --damageMultiplier = (2 - 100 / (100 - targetArmor)) * damageMultiplier
        damageMultiplier = 1 * damageMultiplier
    else
        damageMultiplier = 100 / (100 + targetArmor) * damageMultiplier
    end

    -- use ability power or ad based damage on turrets
    if source.type == myHero.type and target.type == "obj_AI_Turret" then
        totalDamage = math.max(source.totalDamage, source.damage + 0.4 * source.ap)
    end

    -- minions deal less damage to enemy heros
    if source.type == "obj_AI_Minion" and target.type == myHero.type and source.team ~= TEAM_NEUTRAL then
        damageMultiplier = 0.60 * damageMultiplier
    end

    -- heros deal less damage to turrets
    if source.type == myHero.type and target.type == "obj_AI_Turret" then
        damageMultiplier = 0.95 * damageMultiplier
    end

    -- minions deal less damage to turrets
    if source.type == "obj_AI_Minion" and target.type == "obj_AI_Turret" then
        damageMultiplier = 0.475 * damageMultiplier
    end

    -- siege minions and superminions take less damage from turrets
    if source.type == "obj_AI_Turret" and (target.charName == "Red_Minion_MechCannon" or target.charName == "Blue_Minion_MechCannon") then
        damageMultiplier = 0.8 * damageMultiplier
    end

    -- caster minions and basic minions take more damage from turrets
    if source.type == "obj_AI_Turret" and (target.charName == "Red_Minion_Wizard" or target.charName == "Blue_Minion_Wizard" or target.charName == "Red_Minion_Basic" or target.charName == "Blue_Minion_Basic") then
        damageMultiplier = (1 / 0.875) * damageMultiplier
    end

    -- turrets deal more damage to all units by default
    if source.type == "obj_AI_Turret" then
        damageMultiplier = 1.05 * damageMultiplier
    end

    -- calculate damage dealt
    local dmg = damageMultiplier * totalDamage
    return dmg
end

function S1mpleOrbWalker:errorC(func, text, critical)
	if not func then func = "Unknown" end
	if not text then text = "Generic" end
	self:printC("Error at: "..func.." || Error Message: "..text)
	if critical and critical == true then
		self:wtf("[CRITICAL] Game Time: "..GetGameTimer().." || os.clock(): "..os.clock().." || Error at: "..func.." || Error Message: "..text)
		error("CRITICAL ERROR, SCRIPT STOPPED")
	else
		self:wtf("[ERROR] Game Time: "..GetGameTimer().." || os.clock(): "..os.clock().." || Error at: "..func.." || Error Message: "..text)
	end
end

function S1mpleOrbWalker:printC(arg)
	if arg then
		print('<font color=\"#515151\">S1mpleOrbWalker</font><font color=\"#000000\"> - </font><font color=\"#cccccc\">'..arg..'</font>')
		self:wtf("[PRINT] "..tostring(arg))
	else
		self:errorC("printC", "no arg", false)
	end
end

function S1mpleOrbWalker:log(arg)
	if arg then
		self:wtf("[LOG] "..tostring(arg))
	else
		self:errorC("log", "no arg", false)
	end
end

function S1mpleOrbWalker:wtf(msg)
	local file = io.open(SCRIPT_PATH.."\\S1mpleOrbWalkerLog.log", "a")
	if file then
		if not msg then msg = "No Message" end
		file:write(msg.."\n")
		file:close()
	else
		error("Could not open Log File")
	end
end

function S1mpleOrbWalker:AddToMenu(Menu)
	self.menu = Menu

	self.menu:addSubMenu('OrbWalker', 'orb')

	self.menu.orb:addSubMenu("Keys", "keys")
		self.menu.orb.keys:addParam('HarassKey', 'Harras Key', SCRIPT_PARAM_ONKEYDOWN, false, string.byte("C"))
		self.menu.orb.keys:addParam('LaneClearKey', 'Laneclear Key', SCRIPT_PARAM_ONKEYDOWN, false, string.byte("V"))
		self.menu.orb.keys:addParam('LastHitKey', 'LastHit Key', SCRIPT_PARAM_ONKEYDOWN, false, string.byte("X"))
		self.menu.orb.keys:addParam('SBTWKey', 'SBTW Key', SCRIPT_PARAM_ONKEYDOWN, false, string.byte(" "))
		self.menu.orb.keys:addParam("mrinfo", "If you are using Movement Reinvented", SCRIPT_PARAM_INFO, "")
		self.menu.orb.keys:addParam("mrinfo2", "these settings will be ignored", SCRIPT_PARAM_INFO, "")

	self.menu.orb:addSubMenu('Advanced', 'adv')
		self.menu.orb.adv:addParam("orbTower", "OrbWalk Towers (Laneclear)", SCRIPT_PARAM_ONOFF, true)
		self.menu.orb.adv:addParam("debug", "Show the Magic", SCRIPT_PARAM_ONOFF, false)
		self.menu.orb.adv:addParam("blockwall", "Block Movement if Wall", SCRIPT_PARAM_ONOFF, false)
	if self.prediction ~= "none" then
		self.menu.orb.adv:addParam("usepred", "Use Health Prediction", SCRIPT_PARAM_ONOFF, true)
		if self.prediction == "FHPred" then
			self.menu.orb.adv:addParam("FHpredbuffer", "FH Prediction Buffer", SCRIPT_PARAM_SLICE,1.5,0,2,2)
		elseif self.prediction == "VPred" then
			self.menu.orb.adv:addParam("VPpredbuffer", "VP Prediction Buffer", SCRIPT_PARAM_SLICE,1.5,0,2,2)
		end
	end
		self.menu.orb.adv:addParam("aacancleprev", "AA Cancle Prevention (Experimental)", SCRIPT_PARAM_ONOFF, false)

	self.menu.orb:addSubMenu('Humanizer', 'human')
		self.menu.orb.human:addParam("moveorderdelay", "Next Move Order Delay", SCRIPT_PARAM_SLICE, 0.25, 0, 2, 1)
		self.menu.orb.human:addParam("inf", "Values > 1 or < 0.1 are not recommended", SCRIPT_PARAM_INFO, "")
		
	self.menu.orb:addSubMenu('Draws', 'draw')
		self.menu.orb.draw:addParam("killable", "Draw Killable Minions", SCRIPT_PARAM_ONOFF, true)
		self.menu.orb.draw:addParam("soon", "Draw Nearly Killable Minions", SCRIPT_PARAM_ONOFF, true)
		self.menu.orb.draw:addParam("aarange", "Show AA range", SCRIPT_PARAM_ONOFF, true)

	self.menu.orb:addSubMenu("Movement Reinvented", "mr")
		self.menu.orb.mr:addParam("enabled", "Enable Movement Reinvented", SCRIPT_PARAM_ONOFF, false)
		self.menu.orb.mr:addSubMenu("Key Settings", "key")
			self.menu.orb.mr.key:addParam("up", "UP", SCRIPT_PARAM_ONKEYDOWN, false, 104)
			self.menu.orb.mr.key:addParam("left", "LEFT", SCRIPT_PARAM_ONKEYDOWN, false, 100)
			self.menu.orb.mr.key:addParam("down", "DOWN", SCRIPT_PARAM_ONKEYDOWN, false, 98)
			self.menu.orb.mr.key:addParam("right", "RIGHT", SCRIPT_PARAM_ONKEYDOWN, false, 102)

			self.menu.orb.mr.key:addParam("upleft", "UPLEFT", SCRIPT_PARAM_ONKEYDOWN, false, 103)
			self.menu.orb.mr.key:addParam("upright", "UPRIGHT", SCRIPT_PARAM_ONKEYDOWN, false, 105)
			self.menu.orb.mr.key:addParam("downleft", "DOWNLEFT", SCRIPT_PARAM_ONKEYDOWN, false, 97)
			self.menu.orb.mr.key:addParam("downright", "DOWNRIGHT", SCRIPT_PARAM_ONKEYDOWN, false, 99)

			self.menu.orb.mr.key:addParam("inf1", "<><><><><><><><><><>", SCRIPT_PARAM_INFO, "")
			self.menu.orb.mr.key:addParam("orbkey", "Change OrbMode", SCRIPT_PARAM_ONKEYDOWN, false, 101)

end

--AUTO UPDATER--

function S1mpleOrbWalker:update()
	if GetGameTimer() > 120 then self:printC("Game is already progressing, skipping Auto Update") return end
	host = "www.scarjit.de"
	file = "/S1mpleScripts/Scripts/BolStudio/OrbWalker/S1mpleOrbWalker.lua"
	name = "S1mpleOrbWalker.lua"
	DL = Download()
	local ServerVersionDATA = GetWebResult("scarjit.de" , "/S1mpleScripts/Scripts/BolStudio/OrbWalker/S1mpleOrbWalker.version")
	if ServerVersionDATA then
		local ServerVersion = tonumber(ServerVersionDATA)
		if ServerVersion then
			if ServerVersion > tonumber(self.version) then
				self:printC("Updating, don't press F9")
				DL:newDL(host, file, name, LIB_PATH, function ()
					self:printC("S1mpleOrbWalker updated, please reload")
					self.hasupdated = true
				end)
			end
		else
			self:printC("An error occured, while updating, please reload")
		end
	else
		self:printC("Could not connect to update Server")
	end
end

class "Download"
function Download:__init()
	socket = require("socket")
	self.aktivedownloads = {}
	self.callbacks = {}

	AddTickCallback(function ()
		self:RemoveDone()
	end)

	class("Async")
	function Async:__init(host, filepath, localname, drawoffset, localpath)
		self.progress = 0
		self.host = host
		self.filepath = filepath
		self.localname = localname
		self.offset = drawoffset
		self.localpath = localpath
		self.CRLF = '\r\n'

		self.headsocket = socket.tcp()
		self.headsocket:settimeout(1)
		self.headsocket:connect(self.host, 80)
		self.headsocket:send('HEAD '..self.filepath..' HTTP/1.1'.. self.CRLF ..'Host: '..self.host.. self.CRLF ..'User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36'.. self.CRLF .. self.CRLF)

		self.HEADdata = ""
		self.DLdata = ""
		self.StartedDownload = false
		self.canDL = true

		AddTickCallback(function ()
			self:tick()
		end)
		AddDrawCallback(function ()
			self:draw()
		end)
	end

	function Async:tick()
		if self.progress == 100 then return end
		if self.HEADcStatus ~= "timeout" and self.HEADcStatus ~= "closed" then
			self.HEADfString, self.HEADcStatus, self.HEADpString = self.headsocket:receive(16);
			if self.HEADfString then
				self.HEADdata = self.HEADdata..self.HEADfString
			elseif self.HEADpString and #self.HEADpString > 0 then
				self.HEADdata = self.HEADdata..self.HEADpString
			end
		elseif self.HEADcStatus == "timeout" then
			self.headsocket:close()
			--Find Lenght
			local begin = string.find(self.HEADdata, "Length: ")
			if begin then
				self.HEADdata = string.sub(self.HEADdata,begin+8)
				local n = 0
				local _break = false
				for i=1, #self.HEADdata do
					local c = tonumber(string.sub(self.HEADdata,i,i))
					if c and _break == false then
						n = n+1
					else
						_break = true
					end
				end
				self.HEADdata = string.sub(self.HEADdata,1,n)
				self.StartedDownload = true
				self.HEADcStatus = "closed"
			end
		end
		if self.HEADcStatus == "closed" and self.StartedDownload == true and self.canDL == true then --Double Check
			self.canDL = false
			self.DLsocket = socket.tcp()
			self.DLsocket:settimeout(1)
			self.DLsocket:connect(self.host, 80)
			--Start Main Download
			self.DLsocket:send('GET '..self.filepath..' HTTP/1.1'.. self.CRLF ..'Host: '..self.host.. self.CRLF ..'User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36'.. self.CRLF .. self.CRLF)
		end
		
		if self.DLsocket and self.DLcStatus ~= "timeout" and self.DLcStatus ~= "closed" then
			self.DLfString, self.DLcStatus, self.DLpString = self.DLsocket:receive(1024);
			
			if ((self.DLfString) or (self.DLpString and #self.DLpString > 0)) then
				self.DLdata = self.DLdata .. (self.DLfString or self.DLpString)
			end

		elseif self.DLcStatus and self.DLcStatus == "timeout" then
			self.DLsocket:close()
			self.DLcStatus = "closed"
			self.DLdata = string.sub(self.DLdata,#self.DLdata-tonumber(self.HEADdata)+1)

			local file = io.open(self.localpath.."\\"..self.localname, "w+b")
			file:write(self.DLdata)
			file:close()
			self.progress = 100
		end

		if self.progress ~= 100 and self.DLdata and #self.DLdata > 0 then
			self.progress = (#self.DLdata/tonumber(self.HEADdata))*100
		end
	end

	function Async:draw()
		if self.progress < 100 then
			DrawTextA("Downloading: "..self.localname,15,50,35+self.offset)
			DrawRectangleOutline(49,50+self.offset,250,20, ARGB(255,255,255,255),1)
			if self.progress ~= 100 then
				DrawLine(50,60+self.offset,50+(2.5*self.progress),60+self.offset,18,ARGB(150,255-self.progress*2.5,self.progress*2.5,255-self.progress*2.5))
				DrawTextA(tostring(math.round(self.progress).." %"), 15,150,52+self.offset)
			end
		end
	end

end

function Download:newDL(host, file, name, path, callback)
	local offset = (#self.aktivedownloads+1)*40
	self.aktivedownloads[#self.aktivedownloads+1] = Async(host, file, name, offset-40, path)
	if not callback then
		callback = (function ()
		end)
	end

	self.callbacks[#self.callbacks+1] = callback

end

function Download:RemoveDone()
	if #self.aktivedownloads == 0 then return end
	local x = {}
	for k, v in pairs(self.aktivedownloads) do
		if math.round(v.progress) < 100 then
			v.offset = k*40-40
			x[#x+1] = v
		else
			self.callbacks[k]()
		end
	end
	self.aktivedownloads = {}
	self.aktivedownloads = x
end


